# Import necessary libraries
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score, classification_report
from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.naive_bayes import GaussianNB, BernoulliNB, MultinomialNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from ipywidgets import interact, widgets
import warnings
from IPython.display import display

warnings.filterwarnings('ignore')

# Load dataset
data = pd.read_csv('diabetes.csv')

# Extract features and target
x = data.iloc[:, :-1]
y = data.iloc[:, -1]

# Display basic information about the dataset
def display_basic_info(df):
    display(df.info())
    display(df.describe())
    display(f"Dataset Size: {df.size}")
    display(f"Shape: {df.shape}")
    display(f"Missing Values: {df.isna().sum()}")
    
display_basic_info(data)

# Function to remove outliers based on IQR
def remove_outliers(df):
    df_clean = df.copy()
    initial_rows = len(df_clean)
    
    # Remove outliers for each numeric column manually
    Q1 = df_clean['Pregnancies'].quantile(0.25)
    Q3 = df_clean['Pregnancies'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['Pregnancies'] >= Q1 - 1.5 * IQR) & (df_clean['Pregnancies'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['Glucose'].quantile(0.25)
    Q3 = df_clean['Glucose'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['Glucose'] >= Q1 - 1.5 * IQR) & (df_clean['Glucose'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['BloodPressure'].quantile(0.25)
    Q3 = df_clean['BloodPressure'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['BloodPressure'] >= Q1 - 1.5 * IQR) & (df_clean['BloodPressure'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['SkinThickness'].quantile(0.25)
    Q3 = df_clean['SkinThickness'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['SkinThickness'] >= Q1 - 1.5 * IQR) & (df_clean['SkinThickness'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['Insulin'].quantile(0.25)
    Q3 = df_clean['Insulin'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['Insulin'] >= Q1 - 1.5 * IQR) & (df_clean['Insulin'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['BMI'].quantile(0.25)
    Q3 = df_clean['BMI'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['BMI'] >= Q1 - 1.5 * IQR) & (df_clean['BMI'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['DiabetesPedigreeFunction'].quantile(0.25)
    Q3 = df_clean['DiabetesPedigreeFunction'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['DiabetesPedigreeFunction'] >= Q1 - 1.5 * IQR) & (df_clean['DiabetesPedigreeFunction'] <= Q3 + 1.5 * IQR)]
    
    Q1 = df_clean['Age'].quantile(0.25)
    Q3 = df_clean['Age'].quantile(0.75)
    IQR = Q3 - Q1
    df_clean = df_clean[(df_clean['Age'] >= Q1 - 1.5 * IQR) & (df_clean['Age'] <= Q3 + 1.5 * IQR)]
    
    removed = initial_rows - len(df_clean)
    print(f"Initial rows: {initial_rows}")
    print(f"Rows after removal: {len(df_clean)}")
    print(f"Removed {removed} outliers ({(removed / initial_rows) * 100:.2f}% of data)")
    
    return df_clean

# Apply outlier removal
data = remove_outliers(data)

# Split numeric and categorical features
numeric_features = data.select_dtypes(exclude=['object']).columns
categorical_features = data.select_dtypes(include=['object']).columns

print("\nNumeric Features:", list(numeric_features))
print("Categorical Features:", list(categorical_features))

# Encoding categorical features
def encode_categorical(df):
    encoder = LabelEncoder()
    df[categorical_features] = df[categorical_features].apply(encoder.fit_transform)
    return df

data = encode_categorical(data)

# Scaling numeric data
def scale_data(df):
    scaler = StandardScaler()
    df[numeric_features] = scaler.fit_transform(df[numeric_features])
    return df

data_scaled = scale_data(data)

# Split data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=0)

# Plotting function with multiple plot types
def plot_data(plot_type):
    if plot_type == 'Pairplot':
        sns.pairplot(data, hue='Outcome')
        plt.show()
        return
    
    # Manually plotting each feature
    sns.histplot(data=data, x='Pregnancies', hue='Outcome', multiple="layer", alpha=0.5) if plot_type == 'Histplot' else None
    sns.histplot(data=data, x='Glucose', hue='Outcome', multiple="layer", alpha=0.5) if plot_type == 'Histplot' else None
    sns.kdeplot(data=data, x='BloodPressure', hue='Outcome') if plot_type == 'Kdeplot' else None
    sns.boxplot(data=data, x='Outcome', y='SkinThickness') if plot_type == 'Boxplot' else None
    plt.show()

# Create interactive widget for selecting plot type
i = interact(
    plot_data,
    plot_type=widgets.Dropdown(
        options=['Histplot', 'Kdeplot', 'Pairplot', 'Boxplot'],
        description='Plot Type',
        value='Histplot'
    )
)
